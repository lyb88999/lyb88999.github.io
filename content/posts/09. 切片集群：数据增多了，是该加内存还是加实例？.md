---
title: "Redis学习笔记——09. 切片集群：数据增多了，是该加内存还是加实例？"
date: 2025-02-28
draft: false
tags: ["学习笔记", "Redis"]
categories: ["学习"]
---

# 切片集群：数据增多了，是该加内存还是加实例？

如果有这样一个需求：要用Redis保存5000万个键值对，每个键值对大约是512B，为了能快速部署并对外提供服务，我们采用云主机来运行Redis实例，那么如何选择云主机的内存容量呢？

这些键值对所占内存空间为5000万*512B=2500万\*1KB，约等于2.5万\*1MB，约等于25\*1GB=25GB，所以想到的第一个方案就是：选择一台32GB内存的云主机来部署Redis，那样既能保存所有的数据，还能留出7GB的内存保证系统的正常运行。同时，还采用RDB做持久化，以保证Redis实例故障后还能用RDB恢复。

但是在使用的时候，发现Redis的响应有时候会很慢，后来用INFO指令查询Redis的`latest_fork_usec`指标值，发现这个指标特别高，都快到秒的级别了。

这和Redis的持久化机制有关系，在用RDB进行持久化的时候，Redis会fork子进程来完成，fork操作的用时和数据量是正相关的，而且在fork的时候，主线程会被阻塞，数据量越大，主线程被阻塞的时间越长，这就是导致Redis响应变慢的原因。

所以就需要新的方案：切片集群，也叫分片集群，是指启动多个Redis实例组成一个集群，然后按照一定的规则，把收到的数据分成多份，每一份用一个实例来保存。回到刚才的场景里，如果把25GB的数据分成5份，每份5GB，使用5个实例来保存，每个实例只需要保存5GB的数据。

![image-20250228095901044](https://lyb-1305354270.cos.ap-beijing.myqcloud.com/lhcos-data/image-20250228095901044.png)

这样的话，每次生成RDB的时候，fork阻塞主线程的时间就会变短，于是解决了刚才说的问题。

### 如何保存更多的数据

**纵向扩展**：升级单个Redis实例的资源配置，包括增加内存容量、增加磁盘容量、使用更高配置的CPU。好处：实现起来简单、直接，而且数据存在哪，客户端访问哪，都是很明确的。缺点：如果数据量过大，fork子进程生成RDB的时候可能会阻塞主线程很久；收到硬件和成本的限制，比如说内存从32GB到64GB容易，但是到1TB，成本就很高了。

**横向扩展**：横向增加当前Redis实例的个数。优点：不用担心单个实例的硬件和成本限制。缺点：涉及到多个实例的分布式管理问题。

![image-20250228100159982](https://lyb-1305354270.cos.ap-beijing.myqcloud.com/lhcos-data/image-20250228100159982.png)

### 数据切片和实例的对应分布关系

在切片集群中，数据需要分布在不同实例上，那么，数据和实例之间如何对应呢？让我们先弄明白切片集群和Redis Cluster的联系和区别。

实际上，切片集群是一种保存大量数据的通用机制，这个机制可以有不同的实现方案。在Redis3.0之前官方并没有针对切片集群提供具体的方案， 在Redis3.0之后，官方提供了一个名为Redis Cluster的方案，用于实现切片集群。这个方案中就规定了数据和实例的对应关系。

具体来说，Redis Cluster方案采用哈希槽（Hash Slot）来处理数据和实例之间的映射关系，一个切片集群有16384个哈希槽，每个键都会根据它的key，被映射到一个哈希槽中。

具体的映射过程分为两步：

1. 首先根据键值对的key，按照CRC算法计算一个16bit的值；
2. 然后，再用这个16bit的值对16384取模，得到0～16383范围内的模数，每个模数代表一个相应编号的哈希槽。

那么，这些哈希槽如何对应到具体的实例上面呢？

在部署Redis Cluster方案时，可以使用cluster create命令创建集群，此时Redis会自动把这些槽平均分配在集群实例上。我们也可以用cluster meet手动建立起实例间的连接，形成集群，然后使用cluster addslots命令，指定每个实例上面的哈希槽数。（可以避免内存大的实例和内存小的实例平均分配数据造成内存小的实例的数据压力较大）

![image-20250228102107242](https://lyb-1305354270.cos.ap-beijing.myqcloud.com/lhcos-data/image-20250228102107242.png)

需要注意的是，**在手动分配哈希槽的时候，需要把16384个哈希槽都分配完，否则Redis集群无法正常工作**。

### 客户端如何定位数据？

在定位键值对数据时，它所处的哈希槽是可以通过计算得到的，这个计算可以在客户端发送请求时来执行。但是，要进一步定位到实例，还需要知道哈希槽分布在哪个实例上面。

一般来说，客户端和集群实例建立连接后，实例就会把哈希槽的分配信息发送给客户端，但是在集群刚刚创建的时候，每个实例只知道自己分配了哪些哈希槽，是不知道其他实例拥有的哈希槽信息的。

但是Redis实例会把自己的哈希槽信息发送给和它相连接的其他实例，来完成哈希槽分配信息的扩散，当实例之间相互连接后，每个实例就有所有哈希槽的映射关系了。

客户端在收到哈希槽信息后，会把哈希槽信息缓存在本地。当客户端请求键值对时，会先计算键对应的哈希槽，然后就可以给对应的实例发送请求了。

然而在集群中，实例和哈希槽的关系并不是一成不变的，最常见的变化有两个：

1. 在集群中，实例有新增或删除，Redis需要重新分配哈希槽；
2. 为了负载均衡，Redis需要把哈希槽在所有实例上面重新分布一遍。

此时，实例间还可以通过相互传递消息，获得最新的哈希槽分配信息，但是客户端就无法第一时间获取这个变化了。这就会导致它缓存的分配信息和最新的分配信息不一致了。为了解决这个问题，Redis Cluster提出了一套**重定向机制**，就是指客户端给一个实例发送数据读写操作时，如果该实例上没有对应的数据，客户端要再给一个新实例发送操作指令。

```
get hello:key
(error) MOVED 13320 172.16.19.5:6379
```

![image-20250228110439788](https://lyb-1305354270.cos.ap-beijing.myqcloud.com/lhcos-data/image-20250228110439788.png)

重定向后还会更新本地缓存。

需要注意的是，在上图中，当客户端给实例2发送命令时，Slot2中的数据已经全部迁移到了实例3，但实际应用中，如果Slot2中的数据较多，就可能出现一种情况：客户端向实例2发送请求，但是Slot2中只有一部分数据迁移到了实例3。在这种部分迁移的情况下，客户端会收到一条ASK报错信息。

```
GET hello:key
(error)ASK 13320 172.16.19.5:6379
```

这个结果中ASK命令表示，客户端请求的键值所在的哈希槽为13320，在172.16.19.5:6379这个实例上，但是这个哈希槽正在迁移，此时，客户端需要先给该实例发送一个ASKING命令。这个命令意思是，让这个实例允许执行客户端接下来发送的命令。然后，客户端再向这个实例发送GET命令读取数据。

![image-20250228111604397](https://lyb-1305354270.cos.ap-beijing.myqcloud.com/lhcos-data/image-20250228111604397.png)

和 MOVED 命令不同，ASK 命令并不会更新客户端缓存的哈希槽分配信息。所以，在上图中，如果客户端再次请求 Slot 2 中的数据，它还是会给实例 2 发送请求。这也就是说，ASK命令的作⽤只是让客户端能给新实例发送⼀次请求，⽽不像 MOVED 命令那样，会更改本地缓存，让后续所有命令都发往新实例。