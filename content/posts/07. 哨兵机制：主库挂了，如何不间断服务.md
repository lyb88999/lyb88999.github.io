---
title: "Redis学习笔记——07. 哨兵机制：主库挂了，如何不间断服务？"
date: 2025-02-25
draft: false
tags: ["学习笔记", "Redis"]
categories: ["学习"]
---

# 哨兵机制：主库挂了，如何不间断服务?

在主从库集群模式下，如果从库发生故障了，客户端可以继续向主库或者其他从库发送请求，进行相关的操作，但是如果主库发生故障了，会直接影响到从库的同步，因为从库没有主库可以进行数据复制操作了。而且也没有实例可以来服务客户端的写请求了。

![image-20250224231019982](https://lyb-1305354270.cos.ap-beijing.myqcloud.com/lhcos-data/image-20250224231019982.png)

所以，如果从库挂了，就需要运行一个新主库，比方说把一个从库切换为主库。

这就涉及到三个问题：

1. 主库真的挂了吗？
2. 该选择哪个从库作为主库？
3. 怎么把新主库的相关信息通知给从库和客户端呢？

这就要提到哨兵机制了，在Redis主从集群中，哨兵机制是实现主从库自动切换的关键机制，它有效地解决了主从复制下故障转移的三个问题。

#### 哨兵机制的基本流程

哨兵其实就是一个运行在特殊模式下的Redis进程，主从库实例运行的同时，它也在运行。哨兵主要负责的就是三个任务：监控、选主和通知。

**监控**：哨兵进程在运行时，周期性地给所有的主从库发送PING命令，检测它们是否仍在线运行，如果从库没有在规定的时间内回复PING命令，哨兵就会把它们标记为下线状态；同样，如果主库没有在规定时间内回复哨兵的PING命令，哨兵就会判定主库下线，然后开始自动切换主库的流程。

这个流程首先是执行哨兵的第二个任务：**选主**。主库挂了之后，哨兵就需要从多个从库里，按照一定的规则选择一个从库实例，把它作为新的主库。这一步完成后，现在的集群里就有了新的主库。

然后，哨兵会执行最后一个任务：**通知**。在执行通知任务时，哨兵会把新主库的连接信息发送给其他从库，让它们执行replicaof命令，和新主库建立连接，并进行数据复制。同时，哨兵会把新主库的连接信息通知给客户端，让它们把新的请求发送到新主库上。

![image-20250224232718205](https://lyb-1305354270.cos.ap-beijing.myqcloud.com/lhcos-data/image-20250224232718205.png)

这三个任务中，通知任务比较简单，哨兵只需要把新的主库信息发送给从库和客户端，让它们和新主库建立连接即可。但是，在监控和选主两个任务中，哨兵需要做出两个决策：

1. 在监控任务中，哨兵需要判断主库是否处于下线状态；
2. 在选主任务中，哨兵也需要决定哪个从库实例作为新主库。

#### 主观下线和客观下线

**主观下线**：哨兵进程会用PING命令检测它自己和主、从库的网络连接情况，从而来判断实例的状态。如果哨兵发现主库或从库对PING命令的响应超时了，那么哨兵就会把它标记为主观下线。

如果检测的是从库，那么哨兵简单地把它标记为主观下线就可以了，因为从库下线的影响一般不太大，集群的对外服务不会中断。但是，如果检测的是主库，哨兵还不能简单地把它标记为主观下线，开启主从切换。因为可能存在下面这种情况：那就是哨兵误判了，其实主库并没有故障。可是，一旦开启了主从切换，后续的选主和通知操作都会带来额外的计算和通信开销。

为了避免这些不必要的开销，我们要特别注意误判的情况：主库实际并没有下线，但哨兵以为它下线了，一般发生在集群网络压力较大，网络拥塞或者主库本身压力比较大的情况下。

那么如何减少误判？哨兵机制通常会采用多实例组成的集群模式进行部署，也被称为**哨兵集群**。引入多个哨兵一起来判断，可以避免单个哨兵因为自身网络状况不好，而误判主库下线的情况。

在判断主库下线时，不能由一个哨兵说了算，而是有大多数哨兵判定主库主观下线了，主库才会被标记为客观下线。同时，会进一步触发哨兵开始主从切换流程。

![image-20250225125118965](https://lyb-1305354270.cos.ap-beijing.myqcloud.com/lhcos-data/image-20250225125118965.png)

#### 如何选定新主库

一般来说，我们把哨兵选择新主库的过程称为"筛选+打分"，简单来说我们先从多个主库中按照**一定**的筛选条件，把不符合条件的从库筛掉，然后再按照**一定**的规则，给剩下的从库逐个打分，把得分最高的从库选为主库。

![image-20250225125606506](https://lyb-1305354270.cos.ap-beijing.myqcloud.com/lhcos-data/image-20250225125606506.png)

在选主时，除了要检查从库的当前在线状态，还要判断它之前的网络连接状态，如果从库总是和主库断连，并且断连次数超出了一定的阈值，我们就有理由相信，这个从库的网络状态不太好，就可以把这个主库筛选掉了。

![image-20250225130455170](https://lyb-1305354270.cos.ap-beijing.myqcloud.com/lhcos-data/image-20250225130455170.png)

接下来就要给剩余的从库打分了。我们可以分别按照三个规则依次进行三轮打分，这三个规则分别是**从库优先级**、**从库复制进度及从库ID号**。只要在某一轮中，有从库得分最高，那么它就是主库了，选主过程到此结束。如果没有出现得分最高的从库，那么继续进行下一轮比较。

第一轮：**优先级最高的从库得分高**

用户可以通过slave-priority配置项，给不同的从库设置不同的优先级。例如，有两个从库，它们内存大小不一样，可以手动给内存大的实例设置一个高优先级，那么选主的时候，如果有一个从库的优先级最高，那么它就是新主库了，否则进行第二轮判断。

第二轮：**和旧主库同步程度最接近的从库得分高**

如何判断从库和旧主库的同步进度呢？

主库会用master_backlog_offset记录当前最新的写操作在real_backlog_buffer中的位置，从库会用slave_backlog_offset记录当前的复制进度。

如果在所有的从库中，有从库的slave_backlog_offset最接近master_backlog_offset，那么就可以把它当作新主库；否则进入下一轮判断。

![image-20250225134850652](https://lyb-1305354270.cos.ap-beijing.myqcloud.com/lhcos-data/image-20250225134850652.png)

第三轮：**ID小的从库得分高**

每个实例都有一个ID。目前，Redis在选主库时，有一个默认的规定：在优先级和复制进度都相同的情况下，ID小的从库得分最高，会被选为新主库。