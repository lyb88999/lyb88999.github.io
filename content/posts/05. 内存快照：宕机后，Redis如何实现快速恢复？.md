# 内存快照：宕机后，Redis如何实现快速恢复？

AOF方法的好处是每次执行只需要记录操作命令，需要持久化的数据量不大。一般而言，只要采用的不是always的持久化策略，就不会对性能产生太大的影响。但是正是因为记录的是操作的命令，而不是实际的数据，所以用AOF日志进行故障恢复的时候需要逐一把日志都记录一遍。如果操作日志非常多，Redis就会恢复得很慢，影响正常使用。那么有没有既可以保证可靠性，还能在宕机时实现快速恢复的方法呢？这就是**内存快照**。

所谓内存快照，就是指内存中的数据在某一时刻的状态记录，对于Redis来说，就是把某一时刻的状态以文件的形式写入到磁盘上。这样一来，即使宕机，快照文件也不会丢失，数据可靠性就得到了保证。这个快照文件就是RDB文件，是Redis Database的缩写。

在数据恢复的时候，我们可以直接把RDB文件读入内存，很快地完成恢复。但我们还要考虑两个问题：

1. 对哪些数据做快照？这关系到快照的执行效率问题；
2. 做快照时，数据还能被增删改吗？这关系到Redis是否被阻塞，能否同时正常处理请求。

### 给哪些内存数据做快照？

Redis的数据都在内存中，为了提供所有数据的可靠性保证，它执行的是全量快照，也就是把内存中所有数据都记录到磁盘中。

对于Redis而言，它的单线程模式就决定了，我们要尽量避免所有会阻塞主线程的操作。

Redis提供了两个命令来生成RDB文件，分别是save和bgsave：

save：在主线程中执行，会导致阻塞；

bgsave：创建一个子进程，专门用于写入RDB文件，避免了主线程的阻塞，这也是Redis生成RDB文件的默认配置。

### 快照时数据能修改吗？

对于内存快照而言，我们不希望数据"动"。

举个例子，我们在时刻t给内存做快照，假设内存的数据量是4GB，磁盘的写入带宽是0.2GB/s，简单来说需要4/0.2=20s才能做完，如果在这20s中，有一个还没被写入磁盘的内存数据A被修改成了A'，那么就会破坏快照的完整性。

但是，如果快照执行期间数据不能被修改的话，也是会有潜在问题的，比如这20s内Redis就不能处理这些数据的写操作，那么无疑会给业务造成巨大影响。

为了快照而暂停写操作，这肯定是不能接受的，所以这个时候Redis就会借助操作系统提供的写时复制技术(Copy-On-Write, COW)，在执行快照的时候，正常处理写操作。

![image-20250224134927951](https://lyb-1305354270.cos.ap-beijing.myqcloud.com/image-20250224134927951.png)

### 可以每秒做一次快照吗？

快照肯定是间隔时间越短越好，这样即使出了故障也不会丢失太多数据，但如果频繁地执行全量快照，也会带来两方面的开销：

1. 频繁地将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没做完，下一个快照又开始了，容易造成恶性循环。
2. bgsave子进程需要通过fork操作从主线程创建出来。虽然子进程在创建后不会再阻塞主线程，但是fork这个过程本身会阻塞主线程，而且主线程占用内存越大，fork时间就越长，如果频繁fork出子进程，这就会阻塞主线程了。

解决办法？增量快照：做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。

![image-20250224135645467](https://lyb-1305354270.cos.ap-beijing.myqcloud.com/image-20250224135645467.png)

如果我们对每一个键值对的修改，都做个记录，那么如果有1w个被修改的键值对，我们就需要有1w条额外的记录，而且有的时候，键值对非常小，比如只有32字节，但是记录它被修改的元数据信息就需要8个字节，这样为了记住这个修改信息，需要引入额外的空间开销就比较大，对于内存资源宝贵的Redis来说就有点得不偿失。

那么有没有什么办法既能利用RDB的快速恢复，又能以较小的开销做到尽量少丢数据呢？

Redis4.0中提出了一个混合使用AOF日志和内存快照的方法，简单来说，**内存快照以一定频率执行，在两次快照之间，使用AOF日志记录这期间所有的命令操作**。

这样一来，RDB不需要很频繁地执行，就避免了频繁地fork对主线程的影响；而且AOF日志也只需要记录两次快照间的操作，也就是说不需要记录所有操作了，因此就不会出现文件过大的情况，也可以避免重写开销。

![image-20250224140247525](https://lyb-1305354270.cos.ap-beijing.myqcloud.com/image-20250224140247525.png)

