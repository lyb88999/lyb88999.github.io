---
title: "Redis学习笔记——03. 高性能IO模型：为什么单线程Redis能那么快"
date: 2025-02-21
draft: false
tags: ["学习笔记", "Redis"]
categories: ["学习"]
---

# 高性能IO模型：为什么单线程Redis能那么快

我们通常说Redis是单线程，主要是指Redis的网络IO和键值对读写是由一个线程来完成的，这也是Redis对外提供键值存储服务的主要流程。但Redis的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程完成的。

### Redis为什么要用单线程？

#### 多线程的开销

对于一个多线程的系统来说，在有合理的资源分配的情况下，可以增加系统中处理请求操作的资源实体，进而提升系统能够同时处理的请求数，即吞吐率。但是如果没有良好的设计，实际得到的结果就会和下图一样。

![image-20250220175940544](https://lyb-1305354270.cos.ap-beijing.myqcloud.com/image-20250220175940544.png)

为啥呢？一个关键的瓶颈在于，系统中通常会存在被多线程同时访问的共享资源，当有多个线程要求改这个共享资源时，为了保证资源共享的正确性，就需要额外的机制进行保证，这就会带来额外的开销。

而且，采用多线程开发一般会引入同步原语保护共享资源的并发访问，这也会降低代码的易调试性和可维护性。为了避免这些问题，Redis直接采用了单线程模式。

### 单线程Redis为什么这么快？

Redis的单线程模型能达到每秒数十万级别的处理能力，为什么？

1. Redis的大部分操作在内存上完成，再加上它使用了高效的数据结构，例如哈希表和跳表，这是它实现高性能的一个重要原因；
2. 另一方面，Redis采用了多路复用机制，使其在网络IO操作中能并发处理大量的客户端请求，实现高吞吐率。

#### 基本IO模型与阻塞点

以Get请求为例，SimpleKV为了处理一个Get请求，需要监听客户端请求(bind/listen)，和客户端建立连接(accept)，从socket中读取请求(recv)，解析客户端发送请求(parse)，根据请求类型读取键值数据(get)，最后给客户端返回结果，即向socket中写回数据(send)。

既然Redis是单线程，那么最基本的一种实现就是在一个线程中依次执行上述操作

![image-20250221115747717](https://lyb-1305354270.cos.ap-beijing.myqcloud.com/lhcos-data/image-20250221115747717.png)

但是在这里的网络IO处理中，有潜在的阻塞点，分别是accept()和recv()，当Redis监听到一个客户端有连接请求，但一直未成功建立起连接时，会阻塞在accept()函数这里，导致其他客户端无法和Redis建立连接。类似的，当Redis通过recv()从一个客户端读取数据时，如果数据一直未到达，Redis也会一直阻塞在recv()。那么这就会导致Redis整个线程阻塞，无法处理其他客户端请求，效率很低。不过，**socket网络模型本身支持非阻塞模式**。

#### 非阻塞模式

在socket模型中，不同操作调用后会返回不同的套接字类型。socket()方法会返回主动套接字，然后调用listen()方法，将主动套接字转化为监听套接字，此时，可以监听来自客户端的连接请求。最后，调用accept()方法接收到达的客户端连接，并返回已连接套接字。

![image-20250221121254890](https://lyb-1305354270.cos.ap-beijing.myqcloud.com/lhcos-data/image-20250221121254890.png)

针对监听套接字，我们可以设置非阻塞模式，当Redis调用accept()但一直没有连接请求到达时，Redis线程可以返回处理其他操作，而不用一直等待。虽然Redis线程不用一直等待，但是总得有机制继续在监听套接字上等待后续连接请求，并在有请求时通知Redis。

针对已连接套接字，我们可以设置非阻塞模式，当Redis调用recv()后，如果已连接的套接字上一直没有数据到达，Redis数据同样可以返回处理其他操作。我们也需要有机制继续监听该已连接套接字，并在有数据时通知Redis。

这样就可以保证Redis线程既不会像基本IO模型中一直在阻塞点等待，也不会导致Redis无法处理实际到达的连接或数据。

至此，Linux中的IO多路复用机制就要登场了。

#### 基于多路复用的高性能I/O模型

Linux中的IO多路复用机制是指一个线程处理多个IO流，也就是我们经常听到的select/epoll机制。简单来说，就是在只运行单线程的情况下，该机制允许内核中同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求和数据请求，一旦有请求到达，就会交给Redis线程去处理，这就实现了一个一个Redis线程处理多个IO流的效果。

![image-20250221133000233](https://lyb-1305354270.cos.ap-beijing.myqcloud.com/lhcos-data/image-20250221133000233.png)

图中的多个FD就是多个套接字，Redis网络框架调用epoll机制，让内核监听这些套接字。此时，Redis线程不会阻塞在某一个特定的监听/已连接套接字上面，所以Redis可以同时和多个客户端连接并处理请求，从而提升并发性。

为了在请求到达时能及时通知到Redis线程，select/poll提供了基于事件的回调机制，也就是一旦监听到FD上有请求到达时，就会触发相应的事件。这些事件会被放入一个事件队列，Redis单线程会对该事件队列进行不断处理，这样一来，Redis无需一直轮询是否有实际请求发生，这样就可以避免造成CPU资源浪费。同时，Redis在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。
