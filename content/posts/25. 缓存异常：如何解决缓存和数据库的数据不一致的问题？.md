---
title: "Redis学习笔记——25. 缓存异常: 如何解决缓存和数据的数据不一致的问题"
date: 2025-03-18
draft: false
tags: ["学习笔记", "Redis"]
categories: ["学习"]
---

# 缓存异常：如何解决缓存和数据库的数据不一致的问题？

## 缓存和数据库的不一致是如何发生的？

数据一致性：

1. 缓存中有数据，那么，缓存中的数据值要和数据库中的值相同。
2. 缓存中本身没有数据，那么，数据库中的值必须是最新值。

不符合上面两种情况的，就属于缓存和数据库的数据不一致的问题了。不过，当缓存的读写模式不同的时候，缓存数据不一致发生的情况不一样，应对方法也有所不同。根据是否接收写请求，我们可以把缓存分成读写缓存和只读缓存。



对于读写缓存来说，如果要对数据进行增删改，就需要在缓存中进行，同时还要根据采取的写回策略，决定是否同步将数据写回到数据库中：

1. 同步直写策略：写缓存时，也同步写数据库，缓存和数据库的内容保持一致。
2. 异步写回策略：写缓存时不同步写数据库，等到数据从缓存中淘汰时，再写回数据库。使用这种策略时，如果数据还没有写回数据库，缓存就发生了故障。那么，数据库中就没有最新的数据了。

所以，对于读写缓存来说，要想保证缓存和数据库中的数据⼀致，就要采⽤同步直写策略。不过，需要注意的是，如果采⽤这种策略，就需要同时更新缓存和数据库。所以，我们要在业务应⽤中使⽤事务机制，来保证缓存和数据库的更新具有原⼦性，也就是说，两者要不⼀起更新，要不都不更新，返回错误信息，进⾏重试。否则，我们就⽆法实现同步直写。

当然，在有些场景下，我们对数据⼀致性的要求可能不是那么⾼，⽐如说缓存的是电商商品的⾮关键属性或者短视频的创建或修改时间等，那么，我们可以使⽤异步写回策略。



对于只读缓存来说，如果有数据新增，会直接写入数据库；而有数据删改时，只需要把只读缓存中的数据标记为无效。这样一来，后续应用再访问这些增删改的页面时，因为缓存中没有对应的数据，就会发生缓存缺失。此时，应用再从数据库中把数据读入缓存，这样后续再访问数据时，就能够直接从数据库读取了。

![image-20250318092917153](https://lyb-1305354270.cos.ap-beijing.myqcloud.com/lhcos-data/image-20250318092917153.png)

那么何时会出现数据不一致的情况呢？

1. 新增数据：如果是新增数据，数据会直接写到数据库中，不用对缓存做任何操作。此时，缓存中本身就没有新增数据，而数据库中是最新值，这种情况符合上面说的数据一致性的第二种情况，所以此时缓存和数据库的数据是一致的。
2. 删改数据：如果发生删改操作，既要更新数据库，也要在缓存中删除数据。如果两个操作无法保证原子性，就会出现数据不一致的问题了。

如图：

先删缓存，后删数据库

![image-20250318093409573](https://lyb-1305354270.cos.ap-beijing.myqcloud.com/lhcos-data/image-20250318093409573.png)

先删数据库，后删缓存

![image-20250318093431571](https://lyb-1305354270.cos.ap-beijing.myqcloud.com/lhcos-data/image-20250318093431571.png)

![image-20250318093451607](https://lyb-1305354270.cos.ap-beijing.myqcloud.com/lhcos-data/image-20250318093451607.png)

## 如何解决数据不一致问题

1. 重试机制：可以要把删除的缓存值或者是要更新的数据库值放到消息队列里，当应用没有能够成功地删除缓存或者是更新数据库值时，可以从消息队列中重新读取这些值，然后再次进行删除或更新。如果能够成功地删除或更新，我们就要把这些值从消息队列去掉，这样就可以保证数据一致性了，否则就需要重试，超过重试次数后，向应用层报错。（适用于两个操作有一个失败的情况）

   ![image-20250318094036560](https://lyb-1305354270.cos.ap-beijing.myqcloud.com/lhcos-data/image-20250318094036560.png)

2. 即使两个操作都没有失败，大量请求并发时，也可能会出现数据不一致的情况：

   情况一：先删除缓存，后更新数据库值

   假设线程A删除缓存之后，还没来得及更新数据库，此时线程B就开始读数据了，那么B发现缓存缺失，就会从数据库里面读然后更新到缓存，那么B读到了旧值，并且将值写到了缓存，这可能还会导致别的线程从缓存中读到旧值。

   等到线程B读完了值，也更新完了缓存，线程A才开始更新数据库，此时缓存中的是旧值，数据库中的是新值，两者就不一致了。

   ![image-20250318094521526](https://lyb-1305354270.cos.ap-beijing.myqcloud.com/lhcos-data/image-20250318094521526.png)

​	解决方案：在线程A更新完数据库后，可以让它先sleep一小段时间，然后再进行一次缓存删除操作。之所	以要加上 sleep 的这段时间，就是为了让线程 B 能够先从数据库读取数据，再把缺失的数据写⼊缓存，然	后，线程 A 再进⾏删除。所以，线程 A sleep 的时间，就需要⼤于线程 B读取数据再写⼊缓存的时间。这个	时间怎么确定呢？建议你在业务程序运⾏的时候，统计下线程读数据和写缓存的操作时间，以此为基础来进	⾏估算。（延迟双删）

​	情况二：先更新数据库值，再删除缓存

​	如果线程 A 删除了数据库中的值，但还没来得及删除缓存值，线程 B 就开始读取数据了，那么此时，线程B 	查询缓存时，发现缓存命中，就会直接从缓存中读取旧值。不过，在这种情况下，如果其他线程并发读缓存	的请求不多，那么，就不会有很多请求读取到旧值。⽽且，线程 A ⼀般也会很快删除缓存值，这样⼀来，	其他线程再次读取时，就会发⽣缓存缺失，进⽽从数据库中读取最新值。所以，这种情况对业务的影响较	⼩。

​	

![image-20250318095204424](https://lyb-1305354270.cos.ap-beijing.myqcloud.com/lhcos-data/image-20250318095204424.png)